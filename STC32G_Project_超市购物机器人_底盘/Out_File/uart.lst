C251 COMPILER V5.60.0,  uart                                                               10/04/24  20:56:40  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE uart
OBJECT MODULE PLACED IN .\Out_File\uart.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE Project\USER\src\uart.c XSMALL INTR2 WARNINGLEVEL(3) OPTIMIZE(0,SPEED)
                    - BROWSE INCDIR(Libraries\libraries;Libraries\seekfree_libraries;Libraries\seekfree_peripheral;Project\CODE;Project\USER\
                    -inc;Project\USER\src;Libraries\seekfree_components) DEBUG PRINT(.\Out_File\uart.lst) TABS(2) OBJECT(.\Out_File\uart.obj)
                    - 

stmt  level    source

    1          #include "headfile.h"
    2          #include "uart.h"
    3          #include "laser_ranging.h"
    4          
    5          unsigned char uart1_tx_counter, uart2_tx_counter, uart3_tx_counter, uart4_tx_counter;   // å‘é€è®¡æ•°
    6          unsigned char uart1_rx_counter, uart2_rx_counter, uart3_rx_counter, uart4_rx_counter;   // æ¥æ”¶è®¡æ•°
    7          bit           uart1_tx_busy, uart2_tx_busy, uart3_tx_busy, uart4_tx_busy;               // å‘é€å¿™æ ‡å¿
             -—
    8          unsigned char uart1_rx_buffer[UART1_BUF_LENGTH];                                        // æ¥æ”¶ç¼“å†²
    9          unsigned char uart2_rx_buffer[UART2_BUF_LENGTH];                                        // æ¥æ”¶ç¼“å†²
   10          unsigned char uart3_rx_buffer[UART3_BUF_LENGTH];                                        // æ¥æ”¶ç¼“å†²
   11          unsigned char uart4_rx_buffer[UART4_BUF_LENGTH];                                        // æ¥æ”¶ç¼“å†²
   12          
   13          void uart_port_init(void)
   14          {
   15   1        P_SW1 |= 0xc0;            //UART1/USART1: RxD(P4.3), TxD(P4.4)
   16   1        P_SW2 |= 0x01;            //UART2/USART2: RxD2(P4.6), TxD2(P4.7)
   17   1      }
   18          
   19          void uart_initialize(unsigned char uart_num)
   20          {
   21   1          switch(uart_num)
   22   1          {
   23   2              case 1:
   24   2                SCON = 0x50;    // 8ä½æ•°æ®,å¯å˜æ³¢ç‰¹ç‡
   25   2                  AUXR |= 0x01;   // ä¸²å£1é€‰æ‹©å®šæ—¶å™¨2ä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
   26   2                  AUXR |= 0x04;   // å®šæ—¶å™¨æ—¶é’Ÿ1Tæ¨¡å¼
   27   2                  T2L = 0xA0;     // è®¾ç½®å®šæ—¶åˆå§‹å€¼
   28   2                  T2H = 0xFC;     // è®¾ç½®å®šæ—¶åˆå§‹å€¼
   29   2                  AUXR |= 0x10;   // å®šæ—¶å™¨2å¼€å§‹è®¡æ—¶
   30   2                  ES = 1;       // ä½¿èƒ½ä¸²å£1ä¸­æ–­
   31   2                  break;
   32   2      
   33   2              case 2:
   34   2                S2CON = 0x50;   // 8ä½æ•°æ®,å¯å˜æ³¢ç‰¹ç‡
   35   2                  AUXR |= 0x04;   // å®šæ—¶å™¨æ—¶é’Ÿ1Tæ¨¡å¼
   36   2                  T2L = 0xA0;     // è®¾ç½®å®šæ—¶åˆå§‹å€¼
   37   2                  T2H = 0xFC;     // è®¾ç½®å®šæ—¶åˆå§‹å€¼
   38   2                  AUXR |= 0x10;   // å®šæ—¶å™¨2å¼€å§‹è®¡æ—¶
   39   2                  IE2 |= 0x01;    // ä½¿èƒ½ä¸²å£2ä¸­æ–­
   40   2                  break;
   41   2      
   42   2              default:
   43   2                  break;
   44   2          }
   45   1      }
   46          
   47          void uart_sendstring(unsigned char uart_num, unsigned char *puts)
   48          {
   49   1          switch(uart_num)
   50   1          {
   51   2              case 1:
   52   2                  for (; *puts != 0;  puts++)                     // é‡åˆ°åœæ­¢ç¬¦0ç»“æŸ
   53   2                  {
   54   3                      SBUF = *puts;
   55   3                      uart1_tx_busy = 1;
C251 COMPILER V5.60.0,  uart                                                               10/04/24  20:56:40  PAGE 2   

   56   3                      while(uart1_tx_busy);
   57   3                  }
   58   2                  break;
   59   2              case 2:
   60   2                  for (; *puts != 0;  puts++)                     // é‡åˆ°åœæ­¢ç¬¦0ç»“æŸ
   61   2                  {
   62   3                      S2BUF = *puts;
   63   3                      uart2_tx_busy = 1;
   64   3                      while(uart2_tx_busy);
   65   3                  }
   66   2                  break;
   67   2              case 3:
   68   2                  for (; *puts != 0;  puts++)                     // é‡åˆ°åœæ­¢ç¬¦0ç»“æŸ
   69   2                  {
   70   3                      S3BUF = *puts;
   71   3                      uart3_tx_busy = 1;
   72   3                      while(uart3_tx_busy);
   73   3                  }
   74   2                  break;
   75   2              case 4:
   76   2                  for (; *puts != 0;  puts++)                     // é‡åˆ°åœæ­¢ç¬¦0ç»“æŸ
   77   2                  {
   78   3                      S4BUF = *puts;
   79   3                      uart4_tx_busy = 1;
   80   3                      while(uart4_tx_busy);
   81   3                  }
   82   2                  break;
   83   2              default:
   84   2                  break;
   85   2          }
   86   1      }
   87          
   88          void uart_sendcmd(unsigned char uart_num, unsigned char *bytes, unsigned char length)
   89          {
   90   1          unsigned char i;
   91   1          switch(uart_num)
   92   1          {
   93   2              case 1:
   94   2                  for (i = 0; i < length; i++)
   95   2                  {
   96   3                      SBUF = bytes[i];
   97   3                      uart1_tx_busy = 1;
   98   3                      while(uart1_tx_busy);
   99   3                  }
  100   2                  break;
  101   2              case 2:
  102   2                  for (i = 0; i < length; i++)
  103   2                  {
  104   3                      S2BUF = bytes[i];
  105   3                      uart2_tx_busy = 1;
  106   3                      while(uart2_tx_busy);
  107   3                  }
  108   2                  break;
  109   2              case 3:
  110   2                  for (i = 0; i < length; i++)
  111   2                  {
  112   3                      S3BUF = bytes[i];
  113   3                      uart3_tx_busy = 1;
  114   3                      while(uart3_tx_busy);
  115   3                  }
  116   2                  break;
  117   2              case 4:
  118   2                  for (i = 0; i < length; i++)
  119   2                  {
  120   3                      S4BUF = bytes[i];
  121   3                      uart4_tx_busy = 1;
C251 COMPILER V5.60.0,  uart                                                               10/04/24  20:56:40  PAGE 3   

  122   3                      while(uart4_tx_busy);
  123   3                  }
  124   2                  break;
  125   2              default:
  126   2                  break;
  127   2          }
  128   1      }
  129          
  130          void uart1_isr(void) interrupt 4
  131          {
  132   1        if (TI)
  133   1        {
  134   2          TI = 0;
  135   2              uart1_tx_busy = 0;
  136   2        }
  137   1        if (RI)
  138   1        {
  139   2          RI = 0;
  140   2              // uart1_rx_buffer[uart1_rx_counter++] = SBUF;
  141   2              // if(uart1_rx_counter >= UART1_BUF_LENGTH) uart1_rx_counter = 0;    // é˜²æ­¢è¶Šç•Œ
  142   2      
  143   2              // ä»¥ä¸Šä¸ºæ™®é€šä¸²å£ä¸­æ–­ä»£ç ï¼Œä»¥ä¸‹æ˜¯ä¸ºæ¿€å…‰æµ‹è·ä»ªè®¾è®¡çš„å¤„ç†ä»£ç 
  144   2              // laser_ranging_irqhandler('x');
  145   2          }
  146   1      }
  147          
  148          
  149          void uart2_isr(void) interrupt 8                                            // ä¸²å£2çš„ä¸­æ–­å‡½æ•°
  150          {
  151   1        if (S2CON & 0x02)                                                     // æ£€æµ‹ä¸²å£2å‘é€ä¸­æ–­
  152   1        {
  153   2          S2CON &= ~0x02;                                                   // æ¸…é™¤ä¸²å£2å‘é€ä¸­æ–­è¯·æ±‚ä½
  154   2              uart2_tx_busy = 0;                                                  // å‘é€ç©ºé—²æ ‡å¿—ä½
  155   2        }
  156   1        if (S2CON & 0x01)                                                     // æ£€æµ‹ä¸²å£2æ¥æ”¶ä¸­æ–­
  157   1        {
  158   2          S2CON &= ~0x01;                                                     // æ¸…é™¤ä¸²å£2æ¥æ”¶ä¸­æ–­è¯·æ±‚ä
             -½
  159   2              // uart2_rx_buffer[uart2_rx_counter] = S2BUF;                          // æ¥æ”¶æ•°æ®å­˜å…¥ç¼“å†
             -²åŒº
  160   2              // if(++uart2_rx_counter >= UART2_BUF_LENGTH) uart2_rx_counter = 0;    // ç¼“å†²åŒºæ»¡, å¾ªç¯
  161   2      
  162   2              // ä»¥ä¸Šä¸ºæ™®é€šä¸²å£ä¸­æ–­ä»£ç ï¼Œä»¥ä¸‹æ˜¯ä¸ºæ¿€å…‰æµ‹è·ä»ªè®¾è®¡çš„å¤„ç†ä»£ç 
  163   2              // laser_ranging_irqhandler('y');
  164   2        }
  165   1      }
  166          
  167          void uart3_isr(void) interrupt 17                                           // ä¸²å£3çš„ä¸­æ–­å‡½æ•°
  168          {
  169   1        if (S3CON & 0x02)                                                     // æ£€æµ‹ä¸²å£3å‘é€ä¸­æ–­
  170   1        {
  171   2          S3CON &= ~0x02;                                                     // æ¸…é™¤ä¸²å£3å‘é€ä¸­æ–­è¯·æ±‚ä
             -½
  172   2              uart3_tx_busy = 0;                                                  // å‘é€ç©ºé—²æ ‡å¿—ä½
  173   2        }
  174   1        if (S3CON & 0x01)                                                     // æ£€æµ‹ä¸²å£3æ¥æ”¶ä¸­æ–­
  175   1        {
  176   2          S3CON &= ~0x01;                                                     // æ¸…é™¤ä¸²å£3æ¥æ”¶ä¸­æ–­è¯·æ±‚ä
             -½
  177   2              uart3_rx_buffer[uart3_rx_counter] = S3BUF;                          // æ¥æ”¶æ•°æ®å­˜å…¥ç¼“å†²åŒ
             -º
  178   2              if(++uart3_rx_counter >= UART3_BUF_LENGTH) uart3_rx_counter = 0;    // ç¼“å†²åŒºæ»¡, å¾ªç¯
  179   2        }
  180   1      }
  181          
  182          void uart4_isr(void) interrupt 18                                           // ä¸²å£4çš„ä¸­æ–­å‡½æ•°
C251 COMPILER V5.60.0,  uart                                                               10/04/24  20:56:40  PAGE 4   

  183          {
  184   1        if (S4CON & 0x02)                                                     // æ£€æµ‹ä¸²å£4å‘é€ä¸­æ–­
  185   1        {
  186   2          S4CON &= ~0x02;                                                     // æ¸…é™¤ä¸²å£4å‘é€ä¸­æ–­è¯·æ±‚ä
             -½
  187   2              uart4_tx_busy = 0;                                                  // å‘é€ç©ºé—²æ ‡å¿—ä½
  188   2        }
  189   1        if (S4CON & 0x01)                                                     // æ£€æµ‹ä¸²å£4æ¥æ”¶ä¸­æ–­
  190   1        {
  191   2          S4CON &= ~0x01;                                                     // æ¸…é™¤ä¸²å£4æ¥æ”¶ä¸­æ–­è¯·æ±‚ä
             -½
  192   2              uart4_rx_buffer[uart4_rx_counter] = S4BUF;                          // æ¥æ”¶æ•°æ®å­˜å…¥ç¼“å†²åŒ
             -º
  193   2              if(++uart4_rx_counter >= UART4_BUF_LENGTH) uart4_rx_counter = 0;    // ç¼“å†²åŒºæ»¡, å¾ªç¯
  194   2        }
  195   1      }
  196          
  197          void uart_running(unsigned char uart_num)
  198          {
  199   1          switch(uart_num)
  200   1          {
  201   2              case 1:
  202   2                  if((uart1_tx_counter != uart1_rx_counter) && (!uart1_tx_busy))          // æ”¶åˆ°æ•°æ®, å‘é
             -€ç©ºé—²
  203   2                  {
  204   3                      SBUF = uart1_rx_buffer[uart1_tx_counter];                           // å‘é€æ•°æ®
  205   3                      uart1_tx_busy = 1;                                                  // æ ‡è®°å¿™
  206   3                      if(++uart1_tx_counter >= UART1_BUF_LENGTH) uart1_tx_counter = 0;    // å¾ªç¯
  207   3                  }
  208   2                  break;
  209   2              case 2:
  210   2                  if((uart2_tx_counter != uart2_rx_counter) && (!uart2_tx_busy))          // æ”¶åˆ°æ•°æ®, å‘é
             -€ç©ºé—²
  211   2                  {
  212   3                      S2BUF = uart2_rx_buffer[uart2_tx_counter];                          // å‘é€æ•°æ®
  213   3                      uart2_tx_busy = 1;                                                  // æ ‡è®°å¿™
  214   3                      if(++uart2_tx_counter >= UART2_BUF_LENGTH) uart2_tx_counter = 0;    // å¾ªç¯
  215   3                  }
  216   2                  break;
  217   2              case 3:
  218   2                  if((uart3_tx_counter != uart3_rx_counter) && (!uart3_tx_busy))          // æ”¶åˆ°æ•°æ®, å‘é
             -€ç©ºé—²
  219   2                  {
  220   3                      S3BUF = uart3_rx_buffer[uart3_tx_counter];                          // å‘é€æ•°æ®
  221   3                      uart3_tx_busy = 1;                                                  // æ ‡è®°å¿™
  222   3                      if(++uart3_tx_counter >= UART3_BUF_LENGTH) uart3_tx_counter = 0;    // å¾ªç¯
  223   3                  }
  224   2                  break;
  225   2              case 4:
  226   2                  if((uart4_tx_counter != uart4_rx_counter) && (!uart4_tx_busy))          // æ”¶åˆ°æ•°æ®, å‘é
             -€ç©ºé—²
  227   2                  {
  228   3                      S4BUF = uart4_rx_buffer[uart4_tx_counter];                          // å‘é€æ•°æ®
  229   3                      uart4_tx_busy = 1;                                                  // æ ‡è®°å¿™
  230   3                      if(++uart4_tx_counter >= UART4_BUF_LENGTH) uart4_tx_counter = 0;    // å¾ªç¯
  231   3                  }
  232   2                  break;
  233   2              default:
  234   2                  break;
  235   2          }
  236   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1015     ------
  ecode size           =    ------     ------
C251 COMPILER V5.60.0,  uart                                                               10/04/24  20:56:40  PAGE 5   

  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        86     ------
  bit size             =         4     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
