C251 COMPILER V5.60.0,  uart                                                               15/04/24  16:07:05  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE uart
OBJECT MODULE PLACED IN .\Out_File\uart.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE Project\USER\src\uart.c XSMALL INTR2 WARNINGLEVEL(3) OPTIMIZE(0,SPEED)
                    - BROWSE INCDIR(Libraries\libraries;Libraries\seekfree_libraries;Libraries\seekfree_peripheral;Project\CODE;Project\USER\
                    -inc;Project\USER\src;Libraries\seekfree_components) DEBUG PRINT(.\Out_File\uart.lst) TABS(2) OBJECT(.\Out_File\uart.obj)
                    - 

stmt  level    source

    1          #include "headfile.h"
    2          #include "uart.h"
    3          #include "laser_ranging.h"
    4          #include "qmc5883.h"
    5          
    6          unsigned char uart1_tx_counter, uart2_tx_counter, uart3_tx_counter, uart4_tx_counter;   // å‘é€è®¡æ•°
    7          unsigned char uart1_rx_counter, uart2_rx_counter, uart3_rx_counter, uart4_rx_counter;   // æ¥æ”¶è®¡æ•°
    8          bit           uart1_tx_busy, uart2_tx_busy, uart3_tx_busy, uart4_tx_busy;               // å‘é€å¿™æ ‡å¿
             -—
    9          unsigned char uart1_rx_buffer[UART1_BUF_LENGTH];                                        // æ¥æ”¶ç¼“å†²
   10          unsigned char uart2_rx_buffer[UART2_BUF_LENGTH];                                        // æ¥æ”¶ç¼“å†²
   11          unsigned char uart3_rx_buffer[UART3_BUF_LENGTH];                                        // æ¥æ”¶ç¼“å†²
   12          unsigned char uart4_rx_buffer[UART4_BUF_LENGTH];                                        // æ¥æ”¶ç¼“å†²
   13          
   14          int qmc5883_magx, qmc5883_magy, qmc5883_magz;
   15          float qmc5883_yaw;
   16          char qmc5883_char_magx[5], qmc5883_char_magy[5], qmc5883_char_magz[5], qmc5883_char_yaw[6];
   17          // unsigned char qmc5883_char_x_start, qmc5883_char_y_start, qmc5883_char_z_start, qmc5883_char_yaw_start
             -;
   18          // unsigned char qmc5883_char_x_end, qmc5883_char_y_end, qmc5883_char_z_end, qmc5883_char_yaw_end;
   19          // unsigned char qmc5883_char_counter;
   20          
   21          void uart_port_init(void)
   22          {
   23   1        P_SW1 |= 0xc0;            //UART1/USART1: RxD(P4.3), TxD(P4.4)
   24   1        P_SW2 |= 0x01;            //UART2/USART2: RxD2(P4.6), TxD2(P4.7)
   25   1      }
   26          
   27          void uart_initialize(unsigned char uart_num)
   28          {
   29   1          switch(uart_num)
   30   1          {
   31   2              case 1:
   32   2                SCON = 0x50;    // 8ä½æ•°æ®,å¯å˜æ³¢ç‰¹ç‡
   33   2                  AUXR |= 0x01;   // ä¸²å£1é€‰æ‹©å®šæ—¶å™¨2ä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
   34   2                  AUXR |= 0x04;   // å®šæ—¶å™¨æ—¶é’Ÿ1Tæ¨¡å¼
   35   2                  T2L = 0xA0;     // è®¾ç½®å®šæ—¶åˆå§‹å€¼
   36   2                  T2H = 0xFC;     // è®¾ç½®å®šæ—¶åˆå§‹å€¼
   37   2                  AUXR |= 0x10;   // å®šæ—¶å™¨2å¼€å§‹è®¡æ—¶
   38   2                  ES = 1;       // ä½¿èƒ½ä¸²å£1ä¸­æ–­
   39   2                  break;
   40   2      
   41   2              case 2:
   42   2                S2CON = 0x50;   // 8ä½æ•°æ®,å¯å˜æ³¢ç‰¹ç‡
   43   2                  AUXR |= 0x04;   // å®šæ—¶å™¨æ—¶é’Ÿ1Tæ¨¡å¼
   44   2                  T2L = 0xA0;     // è®¾ç½®å®šæ—¶åˆå§‹å€¼
   45   2                  T2H = 0xFC;     // è®¾ç½®å®šæ—¶åˆå§‹å€¼
   46   2                  AUXR |= 0x10;   // å®šæ—¶å™¨2å¼€å§‹è®¡æ—¶
   47   2                  IE2 |= 0x01;    // ä½¿èƒ½ä¸²å£2ä¸­æ–­
   48   2                  break;
   49   2      
   50   2              default:
   51   2                  break;
   52   2          }
   53   1      }
   54          
C251 COMPILER V5.60.0,  uart                                                               15/04/24  16:07:05  PAGE 2   

   55          void uart_sendstring(unsigned char uart_num, unsigned char *puts)
   56          {
   57   1          switch(uart_num)
   58   1          {
   59   2              case 1:
   60   2                  for (; *puts != 0;  puts++)                     // é‡åˆ°åœæ­¢ç¬¦0ç»“æŸ
   61   2                  {
   62   3                      SBUF = *puts;
   63   3                      uart1_tx_busy = 1;
   64   3                      while(uart1_tx_busy);
   65   3                  }
   66   2                  break;
   67   2              case 2:
   68   2                  for (; *puts != 0;  puts++)                     // é‡åˆ°åœæ­¢ç¬¦0ç»“æŸ
   69   2                  {
   70   3                      S2BUF = *puts;
   71   3                      uart2_tx_busy = 1;
   72   3                      while(uart2_tx_busy);
   73   3                  }
   74   2                  break;
   75   2              case 3:
   76   2                  for (; *puts != 0;  puts++)                     // é‡åˆ°åœæ­¢ç¬¦0ç»“æŸ
   77   2                  {
   78   3                      S3BUF = *puts;
   79   3                      uart3_tx_busy = 1;
   80   3                      while(uart3_tx_busy);
   81   3                  }
   82   2                  break;
   83   2              case 4:
   84   2                  for (; *puts != 0;  puts++)                     // é‡åˆ°åœæ­¢ç¬¦0ç»“æŸ
   85   2                  {
   86   3                      S4BUF = *puts;
   87   3                      uart4_tx_busy = 1;
   88   3                      while(uart4_tx_busy);
   89   3                  }
   90   2                  break;
   91   2              default:
   92   2                  break;
   93   2          }
   94   1      }
   95          
   96          void uart_sendcmd(unsigned char uart_num, unsigned char *bytes, unsigned char length)
   97          {
   98   1          unsigned char i;
   99   1          switch(uart_num)
  100   1          {
  101   2              case 1:
  102   2                  for (i = 0; i < length; i++)
  103   2                  {
  104   3                      SBUF = bytes[i];
  105   3                      uart1_tx_busy = 1;
  106   3                      while(uart1_tx_busy);
  107   3                  }
  108   2                  break;
  109   2              case 2:
  110   2                  for (i = 0; i < length; i++)
  111   2                  {
  112   3                      S2BUF = bytes[i];
  113   3                      uart2_tx_busy = 1;
  114   3                      while(uart2_tx_busy);
  115   3                  }
  116   2                  break;
  117   2              case 3:
  118   2                  for (i = 0; i < length; i++)
  119   2                  {
  120   3                      S3BUF = bytes[i];
C251 COMPILER V5.60.0,  uart                                                               15/04/24  16:07:05  PAGE 3   

  121   3                      uart3_tx_busy = 1;
  122   3                      while(uart3_tx_busy);
  123   3                  }
  124   2                  break;
  125   2              case 4:
  126   2                  for (i = 0; i < length; i++)
  127   2                  {
  128   3                      S4BUF = bytes[i];
  129   3                      uart4_tx_busy = 1;
  130   3                      while(uart4_tx_busy);
  131   3                  }
  132   2                  break;
  133   2              default:
  134   2                  break;
  135   2          }
  136   1      }
  137          
  138          void uart1_isr(void) interrupt 4
  139          {
  140   1        if (TI)
  141   1        {
  142   2          TI = 0;
  143   2              uart1_tx_busy = 0;
  144   2        }
  145   1        if (RI)
  146   1        {
  147   2          RI = 0;
  148   2              uart1_rx_buffer[uart1_rx_counter++] = SBUF;
  149   2              if(uart1_rx_counter >= UART1_BUF_LENGTH) uart1_rx_counter = 0;    // é˜²æ­¢è¶Šç•Œ
  150   2      
  151   2              // ä»¥ä¸Šä¸ºæ™®é€šä¸²å£ä¸­æ–­ä»£ç ï¼Œä»¥ä¸‹æ˜¯ä¸ºæ¿€å…‰æµ‹è·ä»ªè®¾è®¡çš„å¤„ç†ä»£ç 
  152   2              laser_ranging_irqhandler('x');
  153   2          }
  154   1      }
  155          
  156          
  157          void uart2_isr(void) interrupt 8                                            // ä¸²å£2çš„ä¸­æ–­å‡½æ•°
  158          {
  159   1        if (S2CON & 0x02)                                                     // æ£€æµ‹ä¸²å£2å‘é€ä¸­æ–­
  160   1        {
  161   2          S2CON &= ~0x02;                                                   // æ¸…é™¤ä¸²å£2å‘é€ä¸­æ–­è¯·æ±‚ä½
  162   2              uart2_tx_busy = 0;                                                  // å‘é€ç©ºé—²æ ‡å¿—ä½
  163   2        }
  164   1        if (S2CON & 0x01)                                                     // æ£€æµ‹ä¸²å£2æ¥æ”¶ä¸­æ–­
  165   1        {
  166   2          S2CON &= ~0x01;                                                     // æ¸…é™¤ä¸²å£2æ¥æ”¶ä¸­æ–­è¯·æ±‚ä
             -½
  167   2              uart2_rx_buffer[uart2_rx_counter] = S2BUF;                          // æ¥æ”¶æ•°æ®å­˜å…¥ç¼“å†²åŒ
             -º
  168   2              if(++uart2_rx_counter >= UART2_BUF_LENGTH) uart2_rx_counter = 0;    // ç¼“å†²åŒºæ»¡, å¾ªç¯
  169   2      
  170   2              // ä»¥ä¸Šä¸ºæ™®é€šä¸²å£ä¸­æ–­ä»£ç ï¼Œä»¥ä¸‹æ˜¯ä¸ºæ¿€å…‰æµ‹è·ä»ªè®¾è®¡çš„å¤„ç†ä»£ç 
  171   2              laser_ranging_irqhandler('y');
  172   2        }
  173   1      }
  174          
  175          void uart3_isr(void) interrupt 17                                           // ä¸²å£3çš„ä¸­æ–­å‡½æ•°
  176          {
  177   1        if (S3CON & 0x02)                                                     // æ£€æµ‹ä¸²å£3å‘é€ä¸­æ–­
  178   1        {
  179   2          S3CON &= ~0x02;                                                     // æ¸…é™¤ä¸²å£3å‘é€ä¸­æ–­è¯·æ±‚ä
             -½
  180   2              uart3_tx_busy = 0;                                                  // å‘é€ç©ºé—²æ ‡å¿—ä½
  181   2        }
  182   1        if (S3CON & 0x01)                                                     // æ£€æµ‹ä¸²å£3æ¥æ”¶ä¸­æ–­
  183   1        {
C251 COMPILER V5.60.0,  uart                                                               15/04/24  16:07:05  PAGE 4   

  184   2          S3CON &= ~0x01;                                                     // æ¸…é™¤ä¸²å£3æ¥æ”¶ä¸­æ–­è¯·æ±‚ä
             -½
  185   2              uart3_rx_buffer[uart3_rx_counter] = S3BUF;                          // æ¥æ”¶æ•°æ®å­˜å…¥ç¼“å†²åŒ
             -º
  186   2              if(++uart3_rx_counter >= UART3_BUF_LENGTH) uart3_rx_counter = 0;    // ç¼“å†²åŒºæ»¡, å¾ªç¯
  187   2      
  188   2              // ä»¥ä¸Šä¸ºæ™®é€šä¸²å£ä¸­æ–­ä»£ç ï¼Œä»¥ä¸‹æ˜¯ä¸ºQMC5883èŠ¯ç‰‡è®¾è®¡çš„å¤„ç†ä»£ç 
  189   2              // æ¥æ”¶Magxæ•°æ®ï¼š
  190   2              if(uart3_rx_buffer[0] == 'M' && uart3_rx_buffer[1] == 'a' && uart3_rx_buffer[2] == 'g' && uart3_r
             -x_buffer[3] == 'x' && uart3_rx_buffer[4] == ':')
  191   2              {
  192   3                  if(uart3_rx_buffer[uart3_rx_counter] != ',')
  193   3                  {
  194   4                      qmc5883_char_magx[uart3_rx_counter - 5] = uart3_rx_buffer[uart3_rx_counter];
  195   4                  }
  196   3                  else
  197   3                  {
  198   4                      uart3_rx_counter = 0;
  199   4                  }
  200   3              }
  201   2              // æ¥æ”¶Magyæ•°æ®ï¼š
  202   2              if(uart3_rx_buffer[0] == 'M' && uart3_rx_buffer[1] == 'a' && uart3_rx_buffer[2] == 'g' && uart3_r
             -x_buffer[3] == 'y' && uart3_rx_buffer[4] == ':')
  203   2              {
  204   3                  if(uart3_rx_buffer[uart3_rx_counter] != ',')
  205   3                  {
  206   4                      qmc5883_char_magy[uart3_rx_counter - 5] = uart3_rx_buffer[uart3_rx_counter];
  207   4                  }
  208   3                  else
  209   3                  {
  210   4                      uart3_rx_counter = 0;
  211   4                  }
  212   3              }
  213   2              // æ¥æ”¶Magzæ•°æ®ï¼š
  214   2              if(uart3_rx_buffer[0] == 'M' && uart3_rx_buffer[1] == 'a' && uart3_rx_buffer[2] == 'g' && uart3_r
             -x_buffer[3] == 'z' && uart3_rx_buffer[4] == ':')
  215   2              {
  216   3                  if(uart3_rx_buffer[uart3_rx_counter] != ',')
  217   3                  {
  218   4                      qmc5883_char_magz[uart3_rx_counter - 5] = uart3_rx_buffer[uart3_rx_counter];
  219   4                  }
  220   3                  else
  221   3                  {
  222   4                      uart3_rx_counter = 0;
  223   4                  }
  224   3              }
  225   2              // æ¥æ”¶Yawæ•°æ®ï¼š
  226   2              if(uart3_rx_buffer[0] == 'Y' && uart3_rx_buffer[1] == 'a' && uart3_rx_buffer[2] == 'w' && uart3_r
             -x_buffer[3] == ':' && uart3_rx_buffer[4] == '1')
  227   2              {
  228   3                  if(uart3_rx_buffer[uart3_rx_counter] != 'M')
  229   3                  {
  230   4                      qmc5883_char_yaw[uart3_rx_counter - 4] = uart3_rx_buffer[uart3_rx_counter];
  231   4                  }
  232   3                  else
  233   3                  {
  234   4                      uart3_rx_counter = 0;
  235   4                  }
  236   3              }
  237   2              // æ¥æ”¶å®Œæ¯•ï¼Œå¼€å§‹è§£ææ•°æ®ï¼š
  238   2      
  239   2      
  240   2              // // æ¥æ”¶æ•°æ®ç¤ºä¾‹ï¼šMagx:2180,Magy:-1285,Magz:-3412,Yaw:120.51
  241   2              // // å¯¹æ•°æ®è¿›è¡Œå¤„ç†ï¼š
  242   2      
  243   2              // // æ£€æŸ¥æ•°æ®å¤´éƒ¨æ˜¯å¦ä¸º"Magx:"
C251 COMPILER V5.60.0,  uart                                                               15/04/24  16:07:05  PAGE 5   

  244   2              // if(uart3_rx_buffer[0] == 'M' && uart3_rx_buffer[1] == 'a' && uart3_rx_buffer[2] == 'g' && uart
             -3_rx_buffer[3] == 'x' && uart3_rx_buffer[4] == ':')
  245   2              // {
  246   2              //     // æ‰¾åˆ°æ•°æ®å¤´éƒ¨ï¼Œå¼€å§‹è§£ææ•°æ®
  247   2              //     // éå†æ•°æ®ä¸­çš„æ¯ä¸ªå­—ç¬¦ï¼Œè®°ç¬¬ä¸€ä¸ª":"å‡ºç°çš„ä½ç½®+1ä¸ºqmc5883_char_x_star
             -tï¼Œè®°ç¬¬ä¸€ä¸ª","å‡ºç°çš„ä½ç½®-1ä¸ºqmc5883_char_x_endï¼›
  248   2              //                     // åŒç†ï¼Œè®°ç¬¬äºŒä¸ª":"å‡ºç°çš„ä½ç½®+1ä¸ºqmc5883_char_y_startï¼Œè®°ç
             -¬¬äºŒä¸ª","å‡ºç°çš„ä½ç½®-1ä¸ºqmc5883_char_y_endï¼›
  249   2              //                     // åŒç†ï¼Œè®°ç¬¬ä¸‰ä¸ª":"å‡ºç°çš„ä½ç½®+1ä¸ºqmc5883_char_z_startï¼Œè®°ç
             -¬¬ä¸‰ä¸ª","å‡ºç°çš„ä½ç½®-1ä¸ºqmc5883_char_z_endï¼›
  250   2              //                     // åŒç†ï¼Œè®°ç¬¬å››ä¸ª":"å‡ºç°çš„ä½ç½®+1ä¸ºqmc5883_char_yaw_startï¼Œè®
             -°bufferæœ€åä¸€ä½çš„ä½ç½®ä¸ºqmc5883_char_yaw_end;
  251   2              //     for(qmc5883_char_counter = 0; qmc5883_char_counter < UART3_BUF_LENGTH; qmc5883_char_counte
             -r++)
  252   2              //     {
  253   2              //         if(uart3_rx_buffer[qmc5883_char_counter] == ':')
  254   2              //         {
  255   2              //             if(qmc5883_char_x_start != 0)
  256   2              //             {
  257   2              //                 qmc5883_char_x_start = qmc5883_char_counter + 1;
  258   2              //             }
  259   2              //             else if(qmc5883_char_y_start != 0)
  260   2              //             {
  261   2              //                 qmc5883_char_y_start = qmc5883_char_counter + 1;
  262   2              //             }
  263   2              //             else if(qmc5883_char_z_start != 0)
  264   2              //             {
  265   2              //                 qmc5883_char_z_start = qmc5883_char_counter + 1;
  266   2              //             }
  267   2              //             else if(qmc5883_char_yaw_start != 0)
  268   2              //             {
  269   2              //                 qmc5883_char_yaw_start = qmc5883_char_counter + 1;
  270   2              //             }
  271   2              //         }
  272   2              //         else if(uart3_rx_buffer[qmc5883_char_counter] == ',')
  273   2              //         {
  274   2              //             if(qmc5883_char_x_end != 0)
  275   2              //             {
  276   2              //                 qmc5883_char_x_end = qmc5883_char_counter - 1;
  277   2              //             }
  278   2              //             else if(qmc5883_char_y_end != 0)
  279   2              //             {
  280   2              //                 qmc5883_char_y_end = qmc5883_char_counter - 1;
  281   2              //             }
  282   2              //             else if(qmc5883_char_z_end != 0)
  283   2              //             {
  284   2              //                 qmc5883_char_z_end = qmc5883_char_counter - 1;
  285   2              //             }
  286   2              //         }
  287   2              //         else
  288   2              //         {
  289   2              //             qmc5883_char_yaw_end = qmc5883_char_counter;
  290   2              //         }
  291   2              //     }
  292   2              //     // å¤´å°¾ä½ç½®æ£€æµ‹ç»“æŸï¼Œå°†æ•°æ®ä¿å­˜åˆ°å˜é‡ä¸­
  293   2              //     for (qmc5883_char_counter = qmc5883_char_x_start; qmc5883_char_counter <= qmc5883_char_x_e
             -nd; qmc5883_char_counter++)
  294   2              //     {
  295   2              //         qmc5883_char_magx[qmc5883_char_counter - qmc5883_char_x_start] = uart3_rx_buffer[qmc58
             -83_char_counter];
  296   2              //     }
  297   2              //     for (qmc5883_char_counter = qmc5883_char_y_start; qmc5883_char_counter <= qmc5883_char_y_e
             -nd; qmc5883_char_counter++)
  298   2              //     {
  299   2              //         qmc5883_char_magy[qmc5883_char_counter - qmc5883_char_y_start] = uart3_rx_buffer[qmc58
             -83_char_counter];
C251 COMPILER V5.60.0,  uart                                                               15/04/24  16:07:05  PAGE 6   

  300   2              //     }
  301   2              //     for (qmc5883_char_counter = qmc5883_char_z_start; qmc5883_char_counter <= qmc5883_char_z_e
             -nd; qmc5883_char_counter++)
  302   2              //     {
  303   2              //         qmc5883_char_magz[qmc5883_char_counter - qmc5883_char_z_start] = uart3_rx_buffer[qmc58
             -83_char_counter];
  304   2              //     }
  305   2              //     for (qmc5883_char_counter = qmc5883_char_yaw_start; qmc5883_char_counter <= qmc5883_char_y
             -aw_end; qmc5883_char_counter++)
  306   2              //     {
  307   2              //         qmc5883_char_yaw[qmc5883_char_counter - qmc5883_char_yaw_start] = uart3_rx_buffer[qmc5
             -883_char_counter];
  308   2              //     }
  309   2              //     // æ•°æ®ä¿å­˜å®Œæ¯•ï¼Œæ¸…ç©ºç¼“å†²åŒºã€è®¡æ•°å™¨
  310   2      
  311   2              //     uart3_rx_counter = 0;
  312   2              //     uart3_rx_buffer[0] = 0;
  313   2              // }
  314   2              // else
  315   2              // {
  316   2              //     // å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°æ•°æ®å¼€å§‹ï¼Œæ¸…ç©ºç¼“å†²åŒºå’Œè®¡æ•°å™¨
  317   2              //     uart3_rx_counter = 0;
  318   2              //     uart3_rx_buffer[0] = 0;
  319   2              //     qmc5883_char_x_start = 0;
  320   2              //     qmc5883_char_y_start = 0;
  321   2              //     qmc5883_char_z_start = 0;
  322   2              //     qmc5883_char_yaw_start = 0;
  323   2              //     qmc5883_char_x_end = 0;
  324   2              //     qmc5883_char_y_end = 0;
  325   2              //     qmc5883_char_z_end = 0;
  326   2              //     qmc5883_char_yaw_end = 0;
  327   2              //     qmc5883_char_counter = 0;
  328   2              // }
  329   2        }
  330   1      }
  331          
  332          
  333          
  334          void uart4_isr(void) interrupt 18                                           // ä¸²å£4çš„ä¸­æ–­å‡½æ•°
  335          {
  336   1        if (S4CON & 0x02)                                                     // æ£€æµ‹ä¸²å£4å‘é€ä¸­æ–­
  337   1        {
  338   2          S4CON &= ~0x02;                                                     // æ¸…é™¤ä¸²å£4å‘é€ä¸­æ–­è¯·æ±‚ä
             -½
  339   2              uart4_tx_busy = 0;                                                  // å‘é€ç©ºé—²æ ‡å¿—ä½
  340   2        }
  341   1        if (S4CON & 0x01)                                                     // æ£€æµ‹ä¸²å£4æ¥æ”¶ä¸­æ–­
  342   1        {
  343   2          S4CON &= ~0x01;                                                     // æ¸…é™¤ä¸²å£4æ¥æ”¶ä¸­æ–­è¯·æ±‚ä
             -½
  344   2              uart4_rx_buffer[uart4_rx_counter] = S4BUF;                          // æ¥æ”¶æ•°æ®å­˜å…¥ç¼“å†²åŒ
             -º
  345   2              if(++uart4_rx_counter >= UART4_BUF_LENGTH) uart4_rx_counter = 0;    // ç¼“å†²åŒºæ»¡, å¾ªç¯
  346   2        }
  347   1      }
  348          
  349          void uart_running(unsigned char uart_num)
  350          {
  351   1          switch(uart_num)
  352   1          {
  353   2              case 1:
  354   2                  if((uart1_tx_counter != uart1_rx_counter) && (!uart1_tx_busy))          // æ”¶åˆ°æ•°æ®, å‘é
             -€ç©ºé—²
  355   2                  {
  356   3                      SBUF = uart1_rx_buffer[uart1_tx_counter];                           // å‘é€æ•°æ®
  357   3                      uart1_tx_busy = 1;                                                  // æ ‡è®°å¿™
C251 COMPILER V5.60.0,  uart                                                               15/04/24  16:07:05  PAGE 7   

  358   3                      if(++uart1_tx_counter >= UART1_BUF_LENGTH) uart1_tx_counter = 0;    // å¾ªç¯
  359   3                  }
  360   2                  break;
  361   2              case 2:
  362   2                  if((uart2_tx_counter != uart2_rx_counter) && (!uart2_tx_busy))          // æ”¶åˆ°æ•°æ®, å‘é
             -€ç©ºé—²
  363   2                  {
  364   3                      S2BUF = uart2_rx_buffer[uart2_tx_counter];                          // å‘é€æ•°æ®
  365   3                      uart2_tx_busy = 1;                                                  // æ ‡è®°å¿™
  366   3                      if(++uart2_tx_counter >= UART2_BUF_LENGTH) uart2_tx_counter = 0;    // å¾ªç¯
  367   3                  }
  368   2                  break;
  369   2              case 3:
  370   2                  if((uart3_tx_counter != uart3_rx_counter) && (!uart3_tx_busy))          // æ”¶åˆ°æ•°æ®, å‘é
             -€ç©ºé—²
  371   2                  {
  372   3                      S3BUF = uart3_rx_buffer[uart3_tx_counter];                          // å‘é€æ•°æ®
  373   3                      uart3_tx_busy = 1;                                                  // æ ‡è®°å¿™
  374   3                      if(++uart3_tx_counter >= UART3_BUF_LENGTH) uart3_tx_counter = 0;    // å¾ªç¯
  375   3                  }
  376   2                  break;
  377   2              case 4:
  378   2                  if((uart4_tx_counter != uart4_rx_counter) && (!uart4_tx_busy))          // æ”¶åˆ°æ•°æ®, å‘é
             -€ç©ºé—²
  379   2                  {
  380   3                      S4BUF = uart4_rx_buffer[uart4_tx_counter];                          // å‘é€æ•°æ®
  381   3                      uart4_tx_busy = 1;                                                  // æ ‡è®°å¿™
  382   3                      if(++uart4_tx_counter >= UART4_BUF_LENGTH) uart4_tx_counter = 0;    // å¾ªç¯
  383   3                  }
  384   2                  break;
  385   2              default:
  386   2                  break;
  387   2          }
  388   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1599     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       133     ------
  bit size             =         4     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
