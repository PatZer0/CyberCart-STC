C251 COMPILER V5.60.0,  uart                                                               22/04/24  18:26:47  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE uart
OBJECT MODULE PLACED IN .\Out_File\uart.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE Project\CODE\uart.c XSMALL INTR2 WARNINGLEVEL(3) OPTIMIZE(0,SPEED) BRO
                    -WSE INCDIR(Libraries\libraries;Libraries\seekfree_libraries;Libraries\seekfree_peripheral;Project\CODE;Project\USER\inc;
                    -Project\USER\src;Libraries\seekfree_components) DEBUG PRINT(.\Out_File\uart.lst) TABS(2) OBJECT(.\Out_File\uart.obj) 

stmt  level    source

    1          #include "uart.h"
    2          #include "laser_ranging.h"
    3          #include "qmc5883.h"
    4          
    5          unsigned char uart1_tx_counter, uart2_tx_counter, uart3_tx_counter, uart4_tx_counter;   // å‘é€è®¡æ•°
    6          unsigned char uart1_rx_counter, uart2_rx_counter, uart3_rx_counter, uart4_rx_counter;   // æ¥æ”¶è®¡æ•°
    7          bit           uart1_tx_busy, uart2_tx_busy, uart3_tx_busy, uart4_tx_busy;               // å‘é€å¿™æ ‡å¿
             -—
    8          unsigned char uart1_rx_buffer[UART1_BUF_LENGTH];                                        // æ¥æ”¶ç¼“å†²
    9          unsigned char uart2_rx_buffer[UART2_BUF_LENGTH];                                        // æ¥æ”¶ç¼“å†²
   10          unsigned char uart3_rx_buffer[UART3_BUF_LENGTH];                                        // æ¥æ”¶ç¼“å†²
   11          unsigned char uart4_rx_buffer[UART4_BUF_LENGTH];                                        // æ¥æ”¶ç¼“å†²
   12          bit           uart1_cr, uart2_cr, uart3_cr, uart4_cr;                                   // å›è½¦æ ‡å¿—
   13          bit           uart1_lf, uart2_lf, uart3_lf, uart4_lf;                                   // æ¢è¡Œæ ‡å¿—
   14          
   15          void uart_port_init(void)
   16          {
   17   1        P_SW1 |= 0xc0;            //UART1/USART1: RxD(P4.3), TxD(P4.4)
   18   1        P_SW2 |= 0x01;            //UART2/USART2: RxD2(P4.6), TxD2(P4.7)
   19   1      }
   20          
   21          void uart_initialize(unsigned char uart_num)
   22          {
   23   1          switch(uart_num)
   24   1          {
   25   2              case 1:
   26   2                SCON = 0x50;    // 8ä½æ•°æ®,å¯å˜æ³¢ç‰¹ç‡
   27   2                  AUXR |= 0x01;   // ä¸²å£1é€‰æ‹©å®šæ—¶å™¨2ä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
   28   2                  AUXR |= 0x04;   // å®šæ—¶å™¨æ—¶é’Ÿ1Tæ¨¡å¼
   29   2                  T2L = 0xA0;     // è®¾ç½®å®šæ—¶åˆå§‹å€¼
   30   2                  T2H = 0xFC;     // è®¾ç½®å®šæ—¶åˆå§‹å€¼
   31   2                  AUXR |= 0x10;   // å®šæ—¶å™¨2å¼€å§‹è®¡æ—¶
   32   2                  ES = 1;       // ä½¿èƒ½ä¸²å£1ä¸­æ–­
   33   2                  break;
   34   2      
   35   2              case 2:
   36   2                S2CON = 0x50;   // 8ä½æ•°æ®,å¯å˜æ³¢ç‰¹ç‡
   37   2                  AUXR |= 0x04;   // å®šæ—¶å™¨æ—¶é’Ÿ1Tæ¨¡å¼
   38   2                  T2L = 0xA0;     // è®¾ç½®å®šæ—¶åˆå§‹å€¼
   39   2                  T2H = 0xFC;     // è®¾ç½®å®šæ—¶åˆå§‹å€¼
   40   2                  AUXR |= 0x10;   // å®šæ—¶å™¨2å¼€å§‹è®¡æ—¶
   41   2                  IE2 |= 0x01;    // ä½¿èƒ½ä¸²å£2ä¸­æ–­
   42   2                  break;
   43   2      
   44   2              default:
   45   2                  break;
   46   2          }
   47   1      }
   48          
   49          void uart_sendstring(unsigned char uart_num, unsigned char *puts)
   50          {
   51   1          switch(uart_num)
   52   1          {
   53   2              case 1:
   54   2                  for (; *puts != 0;  puts++)                     // é‡åˆ°åœæ­¢ç¬¦0ç»“æŸ
   55   2                  {
   56   3                      SBUF = *puts;
C251 COMPILER V5.60.0,  uart                                                               22/04/24  18:26:47  PAGE 2   

   57   3                      uart1_tx_busy = 1;
   58   3                      while(uart1_tx_busy);
   59   3                  }
   60   2                  break;
   61   2              case 2:
   62   2                  for (; *puts != 0;  puts++)                     // é‡åˆ°åœæ­¢ç¬¦0ç»“æŸ
   63   2                  {
   64   3                      S2BUF = *puts;
   65   3                      uart2_tx_busy = 1;
   66   3                      while(uart2_tx_busy);
   67   3                  }
   68   2                  break;
   69   2              case 3:
   70   2                  for (; *puts != 0;  puts++)                     // é‡åˆ°åœæ­¢ç¬¦0ç»“æŸ
   71   2                  {
   72   3                      S3BUF = *puts;
   73   3                      uart3_tx_busy = 1;
   74   3                      while(uart3_tx_busy);
   75   3                  }
   76   2                  break;
   77   2              case 4:
   78   2                  for (; *puts != 0;  puts++)                     // é‡åˆ°åœæ­¢ç¬¦0ç»“æŸ
   79   2                  {
   80   3                      S4BUF = *puts;
   81   3                      uart4_tx_busy = 1;
   82   3                      while(uart4_tx_busy);
   83   3                  }
   84   2                  break;
   85   2              default:
   86   2                  break;
   87   2          }
   88   1      }
   89          
   90          void uart_sendcmd(unsigned char uart_num, unsigned char *bytes, unsigned char length)
   91          {
   92   1          unsigned char i;
   93   1          switch(uart_num)
   94   1          {
   95   2              case 1:
   96   2                  for (i = 0; i < length; i++)
   97   2                  {
   98   3                      SBUF = bytes[i];
   99   3                      uart1_tx_busy = 1;
  100   3                      while(uart1_tx_busy);
  101   3                  }
  102   2                  break;
  103   2              case 2:
  104   2                  for (i = 0; i < length; i++)
  105   2                  {
  106   3                      S2BUF = bytes[i];
  107   3                      uart2_tx_busy = 1;
  108   3                      while(uart2_tx_busy);
  109   3                  }
  110   2                  break;
  111   2              case 3:
  112   2                  for (i = 0; i < length; i++)
  113   2                  {
  114   3                      S3BUF = bytes[i];
  115   3                      uart3_tx_busy = 1;
  116   3                      while(uart3_tx_busy);
  117   3                  }
  118   2                  break;
  119   2              case 4:
  120   2                  for (i = 0; i < length; i++)
  121   2                  {
  122   3                      S4BUF = bytes[i];
C251 COMPILER V5.60.0,  uart                                                               22/04/24  18:26:47  PAGE 3   

  123   3                      uart4_tx_busy = 1;
  124   3                      while(uart4_tx_busy);
  125   3                  }
  126   2                  break;
  127   2              default:
  128   2                  break;
  129   2          }
  130   1      }
  131          
  132          void uart_sendbyte(unsigned char uart_num, unsigned char byte)
  133          {
  134   1          switch(uart_num)
  135   1          {
  136   2              case 1:
  137   2                  SBUF = byte;
  138   2                  uart1_tx_busy = 1;
  139   2                  while(uart1_tx_busy);
  140   2                  break;
  141   2              case 2:
  142   2                  S2BUF = byte;
  143   2                  uart2_tx_busy = 1;
  144   2                  while(uart2_tx_busy);
  145   2                  break;
  146   2              case 3:
  147   2                  S3BUF = byte;
  148   2                  uart3_tx_busy = 1;
  149   2                  while(uart3_tx_busy);
  150   2                  break;
  151   2              case 4:
  152   2                  S4BUF = byte;
  153   2                  uart4_tx_busy = 1;
  154   2                  while(uart4_tx_busy);
  155   2                  break;
  156   2              default:
  157   2                  break;
  158   2          }
  159   1      }
  160          
  161          void uart1_isr(void) interrupt 4
  162          {
  163   1        if (TI)
  164   1        {
  165   2          TI = 0;
  166   2              uart1_tx_busy = 0;
  167   2        }
  168   1        if (RI)
  169   1        {
  170   2          RI = 0;
  171   2              uart1_rx_buffer[uart1_rx_counter++] = SBUF;
  172   2              if(uart1_rx_counter >= UART1_BUF_LENGTH) uart1_rx_counter = 0;      // ç¼“å†²åŒºæ»¡, å¾ªç¯
  173   2              // ---------------- æ”¾ç½®ä¸“ç”¨ä¸²å£ä¸­æ–­å¤„ç†ä»£ç å‡½æ•° ------------------
  174   2          }
  175   1      }
  176          
  177          
  178          void uart2_isr(void) interrupt 8                                            // ä¸²å£2çš„ä¸­æ–­å‡½æ•°
  179          {
  180   1        if (S2CON & 0x02)                                                     // æ£€æµ‹ä¸²å£2å‘é€ä¸­æ–­
  181   1        {
  182   2          S2CON &= ~0x02;                                                   // æ¸…é™¤ä¸²å£2å‘é€ä¸­æ–­è¯·æ±‚ä½
  183   2              uart2_tx_busy = 0;                                                  // å‘é€ç©ºé—²æ ‡å¿—ä½
  184   2        }
  185   1        if (S2CON & 0x01)                                                     // æ£€æµ‹ä¸²å£2æ¥æ”¶ä¸­æ–­
  186   1        {
  187   2          S2CON &= ~0x01;                                                     // æ¸…é™¤ä¸²å£2æ¥æ”¶ä¸­æ–­è¯·æ±‚ä
             -½
C251 COMPILER V5.60.0,  uart                                                               22/04/24  18:26:47  PAGE 4   

  188   2              uart2_rx_buffer[uart2_rx_counter] = S2BUF;                          // æ¥æ”¶æ•°æ®å­˜å…¥ç¼“å†²åŒ
             -º
  189   2              if(uart2_rx_counter >= UART2_BUF_LENGTH) uart2_rx_counter = 0;      // ç¼“å†²åŒºæ»¡, å¾ªç¯
  190   2              // ---------------- æ”¾ç½®ä¸“ç”¨ä¸²å£ä¸­æ–­å¤„ç†ä»£ç å‡½æ•° ------------------
  191   2              // laser_ranging_irqhandler('y');
  192   2        }
  193   1      }
  194          
  195          void uart3_isr(void) interrupt 17                                           // ä¸²å£3çš„ä¸­æ–­å‡½æ•°
  196          {
  197   1        if (S3CON & 0x02)                                                     // æ£€æµ‹ä¸²å£3å‘é€ä¸­æ–­
  198   1        {
  199   2          S3CON &= ~0x02;                                                     // æ¸…é™¤ä¸²å£3å‘é€ä¸­æ–­è¯·æ±‚ä
             -½
  200   2              uart3_tx_busy = 0;                                                  // å‘é€ç©ºé—²æ ‡å¿—ä½
  201   2        }
  202   1        if (S3CON & 0x01)                                                     // æ£€æµ‹ä¸²å£3æ¥æ”¶ä¸­æ–­
  203   1        {
  204   2          S3CON &= ~0x01;                                                     // æ¸…é™¤ä¸²å£3æ¥æ”¶ä¸­æ–­è¯·æ±‚ä
             -½
  205   2              uart3_rx_buffer[uart3_rx_counter] = S3BUF;                          // æ¥æ”¶æ•°æ®å­˜å…¥ç¼“å†²åŒ
             -º
  206   2      
  207   2              // å…¶ä»–ä¸ºæ™®é€šä¸²å£ä¸­æ–­ä»£ç ï¼Œä»¥ä¸‹æ˜¯ä¸ºQMC5883ç£åŠ›ä¼ æ„Ÿå™¨è®¾è®¡çš„å¤„ç†ä»£ç    
             -                                                               
  208   2              if((uart3_rx_buffer[uart3_rx_counter - 1] == 0x0D) && (uart3_rx_buffer[uart3_rx_counter] == 0x0A)
             -)
  209   2              {
  210   3                  // å¦‚æœæ¥æ”¶åˆ°'\r\n'å­—ç¬¦ä»£è¡¨ä¸€è¡Œæ•°æ®æ¥æ”¶å®Œæˆï¼Œåˆ™å°†ç¼“å­˜å…¨éƒ¨ä¿å­˜å¹¶æ¸…
             -ç©ºç¼“å­˜åŒº
  211   3                  memcpy(qmc5883_data, uart3_rx_buffer, sizeof(uart3_rx_buffer));     // ä¿å­˜æ•°æ®
  212   3                  uart3_rx_counter = 0;                                               // æ¸…ç©ºç¼“å­˜åŒº
  213   3                  qmc5883_data_parse(qmc5883_data);                                   // è§£ææ•°æ®
  214   3                  // oled_p6x8str_spi(5*6, 2, qmc5883_char_magx);
  215   3                  // oled_p6x8str_spi(5*6, 3, qmc5883_char_magy);
  216   3                  // oled_p6x8str_spi(5*6, 4, qmc5883_char_magz);
  217   3                  // oled_p6x8str_spi(4*6, 5, qmc5883_char_yaw);
  218   3                  oled_printf_int32_spi(5*6, 2, qmc5883_magx, 10);
  219   3                  oled_printf_int32_spi(5*6, 3, qmc5883_magy, 10);
  220   3                  oled_printf_int32_spi(5*6, 4, qmc5883_magz, 10);
  221   3                  oled_printf_float_spi(4*6, 5, qmc5883_yaw, 4, 2);
  222   3              }
  223   2              // ä¸“ç”¨ä»£ç ç»“æŸ
  224   2      
  225   2              if(++uart3_rx_counter >= UART3_BUF_LENGTH) uart3_rx_counter = 0;    // ç¼“å†²åŒºæ»¡, å¾ªç¯
  226   2      
  227   2      
  228   2        }
  229   1      }
  230          
  231          void uart4_isr(void) interrupt 18                                           // ä¸²å£4çš„ä¸­æ–­å‡½æ•°
  232          {
  233   1        if (S4CON & 0x02)                                                     // æ£€æµ‹ä¸²å£4å‘é€ä¸­æ–­
  234   1        {
  235   2          S4CON &= ~0x02;                                                     // æ¸…é™¤ä¸²å£4å‘é€ä¸­æ–­è¯·æ±‚ä
             -½
  236   2              uart4_tx_busy = 0;                                                  // å‘é€ç©ºé—²æ ‡å¿—ä½
  237   2        }
  238   1        if (S4CON & 0x01)                                                     // æ£€æµ‹ä¸²å£4æ¥æ”¶ä¸­æ–­
  239   1        {
  240   2          S4CON &= ~0x01;                                                     // æ¸…é™¤ä¸²å£4æ¥æ”¶ä¸­æ–­è¯·æ±‚ä
             -½
  241   2              uart4_rx_buffer[uart4_rx_counter] = S4BUF;                          // æ¥æ”¶æ•°æ®å­˜å…¥ç¼“å†²åŒ
             -º
  242   2              if(uart4_rx_counter >= UART4_BUF_LENGTH) uart4_rx_counter = 0;      // ç¼“å†²åŒºæ»¡, å¾ªç¯
  243   2              // ---------------- æ”¾ç½®ä¸“ç”¨ä¸²å£ä¸­æ–­å¤„ç†ä»£ç å‡½æ•° ------------------
C251 COMPILER V5.60.0,  uart                                                               22/04/24  18:26:47  PAGE 5   

  244   2              // laser_ranging_irqhandler('x');
  245   2        }
  246   1      }
  247          
  248          void uart_running(unsigned char uart_num)
  249          {
  250   1          switch(uart_num)
  251   1          {
  252   2              case 1:
  253   2                  if((uart1_tx_counter != uart1_rx_counter) && (!uart1_tx_busy))          // æ”¶åˆ°æ•°æ®, å‘é
             -€ç©ºé—²
  254   2                  {
  255   3                      SBUF = uart1_rx_buffer[uart1_tx_counter];                           // å‘é€æ•°æ®
  256   3                      uart1_tx_busy = 1;                                                  // æ ‡è®°å¿™
  257   3                      if(++uart1_tx_counter >= UART1_BUF_LENGTH) uart1_tx_counter = 0;    // å¾ªç¯
  258   3                  }
  259   2                  break;
  260   2              case 2:
  261   2                  if((uart2_tx_counter != uart2_rx_counter) && (!uart2_tx_busy))          // æ”¶åˆ°æ•°æ®, å‘é
             -€ç©ºé—²
  262   2                  {
  263   3                      S2BUF = uart2_rx_buffer[uart2_tx_counter];                          // å‘é€æ•°æ®
  264   3                      uart2_tx_busy = 1;                                                  // æ ‡è®°å¿™
  265   3                      if(++uart2_tx_counter >= UART2_BUF_LENGTH) uart2_tx_counter = 0;    // å¾ªç¯
  266   3                  }
  267   2                  break;
  268   2              case 3:
  269   2                  if((uart3_tx_counter != uart3_rx_counter) && (!uart3_tx_busy))          // æ”¶åˆ°æ•°æ®, å‘é
             -€ç©ºé—²
  270   2                  {
  271   3                      S3BUF = uart3_rx_buffer[uart3_tx_counter];                          // å‘é€æ•°æ®
  272   3                      uart3_tx_busy = 1;                                                  // æ ‡è®°å¿™
  273   3                      if(++uart3_tx_counter >= UART3_BUF_LENGTH) uart3_tx_counter = 0;    // å¾ªç¯
  274   3                  }
  275   2                  break;
  276   2              case 4:
  277   2                  if((uart4_tx_counter != uart4_rx_counter) && (!uart4_tx_busy))          // æ”¶åˆ°æ•°æ®, å‘é
             -€ç©ºé—²
  278   2                  {
  279   3                      S4BUF = uart4_rx_buffer[uart4_tx_counter];                          // å‘é€æ•°æ®
  280   3                      uart4_tx_busy = 1;                                                  // æ ‡è®°å¿™
  281   3                      if(++uart4_tx_counter >= UART4_BUF_LENGTH) uart4_tx_counter = 0;    // å¾ªç¯
  282   3                  }
  283   2                  break;
  284   2              default:
  285   2                  break;
  286   2          }
  287   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1364     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       168     ------
  bit size             =        12     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
C251 COMPILER V5.60.0,  uart                                                               22/04/24  18:26:47  PAGE 6   

  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
