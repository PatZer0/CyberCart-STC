C251 COMPILER V5.60.0,  uart                                                               26/04/24  14:52:51  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE uart
OBJECT MODULE PLACED IN .\Out_File\uart.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE Project\CODE\uart.c XSMALL INTR2 WARNINGLEVEL(3) OPTIMIZE(0,SPEED) BRO
                    -WSE INCDIR(Libraries\libraries;Libraries\seekfree_libraries;Libraries\seekfree_peripheral;Project\CODE;Project\USER\inc;
                    -Project\USER\src;Libraries\seekfree_components) DEBUG PRINT(.\Out_File\uart.lst) TABS(2) OBJECT(.\Out_File\uart.obj) 

stmt  level    source

    1          #include "headfile.h"
    2          #include "uart.h"
    3          #include "laser_ranging.h"
    4          #include "host_comm.h"
    5          #include "qmc5883.h"
    6          
    7          unsigned char uart1_tx_counter, uart2_tx_counter, uart3_tx_counter, uart4_tx_counter;   // å‘é€è®¡æ•°
    8          unsigned char uart1_rx_counter, uart2_rx_counter, uart3_rx_counter, uart4_rx_counter;   // æ¥æ”¶è®¡æ•°
    9          bit           uart1_tx_busy, uart2_tx_busy, uart3_tx_busy, uart4_tx_busy;               // å‘é€å¿™æ ‡å¿
             -—
   10          unsigned char uart1_rx_buffer[UART1_BUF_LENGTH];                                        // æ¥æ”¶ç¼“å†²
   11          unsigned char uart2_rx_buffer[UART2_BUF_LENGTH];                                        // æ¥æ”¶ç¼“å†²
   12          unsigned char uart3_rx_buffer[UART3_BUF_LENGTH];                                        // æ¥æ”¶ç¼“å†²
   13          unsigned char uart4_rx_buffer[UART4_BUF_LENGTH];                                        // æ¥æ”¶ç¼“å†²
   14          bit           uart1_cr, uart2_cr, uart3_cr, uart4_cr;                                   // å›è½¦æ ‡å¿—
   15          bit           uart1_lf, uart2_lf, uart3_lf, uart4_lf;                                   // æ¢è¡Œæ ‡å¿—
   16          bit           uart1_rx_rdy, uart2_rx_rdy, uart3_rx_rdy, uart4_rx_rdy;                   // æ¥æ”¶æ•°æ®å‡
             -†å¤‡å¥½æ ‡å¿—
   17          
   18          void uart_port_init(void)
   19          {
   20   1        P_SW1 |= 0xc0;            //UART1/USART1: RxD(P4.3), TxD(P4.4)
   21   1        P_SW2 |= 0x01;            //UART2/USART2: RxD2(P4.6), TxD2(P4.7)
   22   1      }
   23          
   24          void uart_initialize(unsigned char uart_num)
   25          {
   26   1          switch(uart_num)
   27   1          {
   28   2              case 1:
   29   2                SCON = 0x50;    // 8ä½æ•°æ®,å¯å˜æ³¢ç‰¹ç‡
   30   2                  AUXR |= 0x01;   // ä¸²å£1é€‰æ‹©å®šæ—¶å™¨2ä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
   31   2                  AUXR |= 0x04;   // å®šæ—¶å™¨æ—¶é’Ÿ1Tæ¨¡å¼
   32   2                  T2L = 0xA0;     // è®¾ç½®å®šæ—¶åˆå§‹å€¼
   33   2                  T2H = 0xFC;     // è®¾ç½®å®šæ—¶åˆå§‹å€¼
   34   2                  AUXR |= 0x10;   // å®šæ—¶å™¨2å¼€å§‹è®¡æ—¶
   35   2                  ES = 1;       // ä½¿èƒ½ä¸²å£1ä¸­æ–­
   36   2                  break;
   37   2      
   38   2              case 2:
   39   2                S2CON = 0x50;   // 8ä½æ•°æ®,å¯å˜æ³¢ç‰¹ç‡
   40   2                  AUXR |= 0x04;   // å®šæ—¶å™¨æ—¶é’Ÿ1Tæ¨¡å¼
   41   2                  T2L = 0xA0;     // è®¾ç½®å®šæ—¶åˆå§‹å€¼
   42   2                  T2H = 0xFC;     // è®¾ç½®å®šæ—¶åˆå§‹å€¼
   43   2                  AUXR |= 0x10;   // å®šæ—¶å™¨2å¼€å§‹è®¡æ—¶
   44   2                  IE2 |= 0x01;    // ä½¿èƒ½ä¸²å£2ä¸­æ–­
   45   2                  break;
   46   2      
   47   2              default:
   48   2                  break;
   49   2          }
   50   1      }
   51          
   52          void uart_sendstring(unsigned char uart_num, unsigned char *puts)
   53          {
   54   1          switch(uart_num)
   55   1          {
C251 COMPILER V5.60.0,  uart                                                               26/04/24  14:52:51  PAGE 2   

   56   2              case 1:
   57   2                  for (; *puts != 0;  puts++)                     // é‡åˆ°åœæ­¢ç¬¦0ç»“æŸ
   58   2                  {
   59   3                      SBUF = *puts;
   60   3                      uart1_tx_busy = 1;
   61   3                      while(uart1_tx_busy);
   62   3                  }
   63   2                  break;
   64   2              case 2:
   65   2                  for (; *puts != 0;  puts++)                     // é‡åˆ°åœæ­¢ç¬¦0ç»“æŸ
   66   2                  {
   67   3                      S2BUF = *puts;
   68   3                      uart2_tx_busy = 1;
   69   3                      while(uart2_tx_busy);
   70   3                  }
   71   2                  break;
   72   2              case 3:
   73   2                  for (; *puts != 0;  puts++)                     // é‡åˆ°åœæ­¢ç¬¦0ç»“æŸ
   74   2                  {
   75   3                      S3BUF = *puts;
   76   3                      uart3_tx_busy = 1;
   77   3                      while(uart3_tx_busy);
   78   3                  }
   79   2                  break;
   80   2              case 4:
   81   2                  for (; *puts != 0;  puts++)                     // é‡åˆ°åœæ­¢ç¬¦0ç»“æŸ
   82   2                  {
   83   3                      S4BUF = *puts;
   84   3                      uart4_tx_busy = 1;
   85   3                      while(uart4_tx_busy);
   86   3                  }
   87   2                  break;
   88   2              default:
   89   2                  break;
   90   2          }
   91   1      }
   92          
   93          void uart_sendcmd(unsigned char uart_num, unsigned char *bytes, unsigned char length)
   94          {
   95   1          unsigned char i;
   96   1          switch(uart_num)
   97   1          {
   98   2              case 1:
   99   2                  for (i = 0; i < length; i++)
  100   2                  {
  101   3                      SBUF = bytes[i];
  102   3                      uart1_tx_busy = 1;
  103   3                      while(uart1_tx_busy);
  104   3                  }
  105   2                  break;
  106   2              case 2:
  107   2                  for (i = 0; i < length; i++)
  108   2                  {
  109   3                      S2BUF = bytes[i];
  110   3                      uart2_tx_busy = 1;
  111   3                      while(uart2_tx_busy);
  112   3                  }
  113   2                  break;
  114   2              case 3:
  115   2                  for (i = 0; i < length; i++)
  116   2                  {
  117   3                      S3BUF = bytes[i];
  118   3                      uart3_tx_busy = 1;
  119   3                      while(uart3_tx_busy);
  120   3                  }
  121   2                  break;
C251 COMPILER V5.60.0,  uart                                                               26/04/24  14:52:51  PAGE 3   

  122   2              case 4:
  123   2                  for (i = 0; i < length; i++)
  124   2                  {
  125   3                      S4BUF = bytes[i];
  126   3                      uart4_tx_busy = 1;
  127   3                      while(uart4_tx_busy);
  128   3                  }
  129   2                  break;
  130   2              default:
  131   2                  break;
  132   2          }
  133   1      }
  134          
  135          void uart_sendbyte(unsigned char uart_num, unsigned char byte)
  136          {
  137   1          switch(uart_num)
  138   1          {
  139   2              case 1:
  140   2                  SBUF = byte;
  141   2                  uart1_tx_busy = 1;
  142   2                  while(uart1_tx_busy);
  143   2                  break;
  144   2              case 2:
  145   2                  S2BUF = byte;
  146   2                  uart2_tx_busy = 1;
  147   2                  while(uart2_tx_busy);
  148   2                  break;
  149   2              case 3:
  150   2                  S3BUF = byte;
  151   2                  uart3_tx_busy = 1;
  152   2                  while(uart3_tx_busy);
  153   2                  break;
  154   2              case 4:
  155   2                  S4BUF = byte;
  156   2                  uart4_tx_busy = 1;
  157   2                  while(uart4_tx_busy);
  158   2                  break;
  159   2              default:
  160   2                  break;
  161   2          }
  162   1      }
  163          
  164          void uart1_isr(void) interrupt 4
  165          {
  166   1        if (TI)
  167   1        {
  168   2          TI = 0;
  169   2              uart1_tx_busy = 0;
  170   2        }
  171   1        if (RI)
  172   1        {
  173   2          RI = 0;
  174   2              uart1_rx_buffer[uart1_rx_counter] = SBUF;
  175   2      
  176   2              // ---------------- æ”¾ç½®ä¸“ç”¨ä¸²å£ä¸­æ–­å¤„ç†ä»£ç å‡½æ•° ------------------
  177   2              if((uart1_rx_buffer[uart1_rx_counter - 1] == 'A') && (uart1_rx_buffer[uart1_rx_counter] == 'T'))
  178   2              {
  179   3                  memset(uart1_rx_buffer, '\0', sizeof(uart1_rx_buffer));
  180   3                  uart1_rx_buffer[0] = 'A';
  181   3                  uart1_rx_buffer[1] = 'T';
  182   3                  uart1_rx_counter = 1;       // é‡ç½®è®¡æ•°å™¨ï¼Œä»ç¼“å†²åŒºå¤´éƒ¨å¼€å§‹å†™å…¥å‰©ä½™çš„å‘½ä»
             -¤
  183   3              }
  184   2              if((uart1_rx_buffer[uart1_rx_counter - 1] == '\r') && (uart1_rx_buffer[uart1_rx_counter] == '\n')
             -)
  185   2              {
C251 COMPILER V5.60.0,  uart                                                               26/04/24  14:52:51  PAGE 4   

  186   3                  host_comm_irqhandler();     // å½“æ£€æµ‹åˆ°\r\nä»£è¡¨å‘½ä»¤æ¥æ”¶å®Œæ¯•ï¼Œè°ƒç”¨host_comm_irq
             -handler()å¤„ç†å‘½ä»¤
  187   3              }
  188   2              // ------------------------ ä¸“ç”¨ä»£ç ç»“æŸ --------------------------
  189   2              if(++uart1_rx_counter >= UART1_BUF_LENGTH) uart1_rx_counter = 0;     // ç¼“å†²åŒºæ»¡, å¾ªç¯
  190   2          }
  191   1      }
  192          
  193          
  194          void uart2_isr(void) interrupt 8                                            // ä¸²å£2çš„ä¸­æ–­å‡½æ•°
  195          {
  196   1        if (S2CON & 0x02)                                                     // æ£€æµ‹ä¸²å£2å‘é€ä¸­æ–­
  197   1        {
  198   2          S2CON &= ~0x02;                                                   // æ¸…é™¤ä¸²å£2å‘é€ä¸­æ–­è¯·æ±‚ä½
  199   2              uart2_tx_busy = 0;                                                  // å‘é€ç©ºé—²æ ‡å¿—ä½
  200   2        }
  201   1        if (S2CON & 0x01)                                                     // æ£€æµ‹ä¸²å£2æ¥æ”¶ä¸­æ–­
  202   1        {
  203   2          S2CON &= ~0x01;                                                     // æ¸…é™¤ä¸²å£2æ¥æ”¶ä¸­æ–­è¯·æ±‚ä
             -½
  204   2              uart2_rx_buffer[uart2_rx_counter] = S2BUF;                          // æ¥æ”¶æ•°æ®å­˜å…¥ç¼“å†²åŒ
             -º
  205   2              // ---------------- æ”¾ç½®ä¸“ç”¨ä¸²å£ä¸­æ–­å¤„ç†ä»£ç å‡½æ•° ------------------
  206   2              // laser_ranging_irqhandler('y');
  207   2              if(++uart2_rx_counter >= UART2_BUF_LENGTH) uart2_rx_counter = 0;      // ç¼“å†²åŒºæ»¡, å¾ªç¯
  208   2        }
  209   1      }
  210          
  211          void uart3_isr(void) interrupt 17                                           // ä¸²å£3çš„ä¸­æ–­å‡½æ•°
  212          {
  213   1        if (S3CON & 0x02)                                                     // æ£€æµ‹ä¸²å£3å‘é€ä¸­æ–­
  214   1        {
  215   2          S3CON &= ~0x02;                                                     // æ¸…é™¤ä¸²å£3å‘é€ä¸­æ–­è¯·æ±‚ä
             -½
  216   2              uart3_tx_busy = 0;                                                  // å‘é€ç©ºé—²æ ‡å¿—ä½
  217   2        }
  218   1        if (S3CON & 0x01)                                                     // æ£€æµ‹ä¸²å£3æ¥æ”¶ä¸­æ–­
  219   1        {
  220   2          S3CON &= ~0x01;                                                     // æ¸…é™¤ä¸²å£3æ¥æ”¶ä¸­æ–­è¯·æ±‚ä
             -½
  221   2              uart3_rx_buffer[uart3_rx_counter] = S3BUF;                          // æ¥æ”¶æ•°æ®å­˜å…¥ç¼“å†²åŒ
             -º
  222   2      
  223   2              // ---------------- æ”¾ç½®ä¸“ç”¨ä¸²å£ä¸­æ–­å¤„ç†ä»£ç å‡½æ•° ------------------
  224   2              qmc5883_irqhandler();
  225   2              // ------------------------ ä¸“ç”¨ä»£ç ç»“æŸ --------------------------
  226   2      
  227   2              if(++uart3_rx_counter >= UART3_BUF_LENGTH) uart3_rx_counter = 0;    // ç¼“å†²åŒºæ»¡, å¾ªç¯
  228   2        }
  229   1      }
  230          
  231          void uart4_isr(void) interrupt 18                                           // ä¸²å£4çš„ä¸­æ–­å‡½æ•°
  232          {
  233   1        if (S4CON & 0x02)                                                     // æ£€æµ‹ä¸²å£4å‘é€ä¸­æ–­
  234   1        {
  235   2          S4CON &= ~0x02;                                                     // æ¸…é™¤ä¸²å£4å‘é€ä¸­æ–­è¯·æ±‚ä
             -½
  236   2              uart4_tx_busy = 0;                                                  // å‘é€ç©ºé—²æ ‡å¿—ä½
  237   2        }
  238   1        if (S4CON & 0x01)                                                     // æ£€æµ‹ä¸²å£4æ¥æ”¶ä¸­æ–­
  239   1        {
  240   2          S4CON &= ~0x01;                                                     // æ¸…é™¤ä¸²å£4æ¥æ”¶ä¸­æ–­è¯·æ±‚ä
             -½
  241   2              uart4_rx_buffer[uart4_rx_counter] = S4BUF;                          // æ¥æ”¶æ•°æ®å­˜å…¥ç¼“å†²åŒ
             -º
  242   2      
C251 COMPILER V5.60.0,  uart                                                               26/04/24  14:52:51  PAGE 5   

  243   2              // ---------------- æ”¾ç½®ä¸“ç”¨ä¸²å£ä¸­æ–­å¤„ç†ä»£ç å‡½æ•° ------------------
  244   2              // laser_ranging_irqhandler('x');
  245   2              // ------------------------ ä¸“ç”¨ä»£ç ç»“æŸ --------------------------
  246   2              if(++uart4_rx_counter >= UART4_BUF_LENGTH) uart4_rx_counter = 0;      // ç¼“å†²åŒºæ»¡, å¾ªç¯
  247   2              
  248   2        }
  249   1      }
  250          
  251          void uart_running(unsigned char uart_num)
  252          {
  253   1          switch(uart_num)
  254   1          {
  255   2              case 1:
  256   2                  if((uart1_tx_counter != uart1_rx_counter) && (!uart1_tx_busy))          // æ”¶åˆ°æ•°æ®, å‘é
             -€ç©ºé—²
  257   2                  {
  258   3                      SBUF = uart1_rx_buffer[uart1_tx_counter];                           // å‘é€æ•°æ®
  259   3                      uart1_tx_busy = 1;                                                  // æ ‡è®°å¿™
  260   3                      if(++uart1_tx_counter >= UART1_BUF_LENGTH) uart1_tx_counter = 0;    // å¾ªç¯
  261   3                  }
  262   2                  break;
  263   2              case 2:
  264   2                  if((uart2_tx_counter != uart2_rx_counter) && (!uart2_tx_busy))          // æ”¶åˆ°æ•°æ®, å‘é
             -€ç©ºé—²
  265   2                  {
  266   3                      S2BUF = uart2_rx_buffer[uart2_tx_counter];                          // å‘é€æ•°æ®
  267   3                      uart2_tx_busy = 1;                                                  // æ ‡è®°å¿™
  268   3                      if(++uart2_tx_counter >= UART2_BUF_LENGTH) uart2_tx_counter = 0;    // å¾ªç¯
  269   3                  }
  270   2                  break;
  271   2              case 3:
  272   2                  if((uart3_tx_counter != uart3_rx_counter) && (!uart3_tx_busy))          // æ”¶åˆ°æ•°æ®, å‘é
             -€ç©ºé—²
  273   2                  {
  274   3                      S3BUF = uart3_rx_buffer[uart3_tx_counter];                          // å‘é€æ•°æ®
  275   3                      uart3_tx_busy = 1;                                                  // æ ‡è®°å¿™
  276   3                      if(++uart3_tx_counter >= UART3_BUF_LENGTH) uart3_tx_counter = 0;    // å¾ªç¯
  277   3                  }
  278   2                  break;
  279   2              case 4:
  280   2                  if((uart4_tx_counter != uart4_rx_counter) && (!uart4_tx_busy))          // æ”¶åˆ°æ•°æ®, å‘é
             -€ç©ºé—²
  281   2                  {
  282   3                      S4BUF = uart4_rx_buffer[uart4_tx_counter];                          // å‘é€æ•°æ®
  283   3                      uart4_tx_busy = 1;                                                  // æ ‡è®°å¿™
  284   3                      if(++uart4_tx_counter >= UART4_BUF_LENGTH) uart4_tx_counter = 0;    // å¾ªç¯
  285   3                  }
  286   2                  break;
  287   2              default:
  288   2                  break;
  289   2          }
  290   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1369     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       232     ------
  bit size             =        16     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
C251 COMPILER V5.60.0,  uart                                                               26/04/24  14:52:51  PAGE 6   

  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
